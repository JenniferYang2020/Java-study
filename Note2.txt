Java语言基础常量与变量
整数常量
小数常量
boolean(True/False)
字符常量：一个数字、字母或者符号用‘ ’标识
字符串： 将一个或多个数字、字母或者符号用“  ”标识
null常量 =null

整数常量包括：
            二进制
            八进制：0-7 满8进1， 用0开头表示
            十进制
            十六进制 0-9 A-F， 满16进1，用0X开头表示

8个0、 1封装成一个单元，即 8个Bite（比特数）= 1 byte 字节 = 8个二进制位

tips：工厂出厂除以1000，电脑出厂除以1024

0110-1011 1个字节表示一个数据，太麻烦，所以有了三个一组表示，即8进制；或者四个一组表示，即16进制。
八进制： 001-101-011
十六进制：1010-1110

总结：
八进制：即二进制位，3个二进制位是一个八进制位
十六进制：也是二进制位，4个二进制位是一个十六进制位


负数二进制表现形式：
整数---四个字节： 0000-0000 0000-0000 0000-0000 0000-0110 （表示6）=>0000-0110
负数： 即这个数的整数的二进制表现形式，取反，再加1 

0000-0110 取反即 1111-1001， 然后加一，即：

    1111-1001
+   0000-0001
--------------------
    1111-1010 ----->这就是-6的表现形式

所以：凡是负数，二进制的最高位是1



变量：变化的数据。 

变量其实是一个内存中的存储区域，即在内存中定义一个空间，在内存中划分一片空间，用于存储数据。
tips:不是在硬盘定义，因为硬盘数据不连续，需要寻找，所以速度会慢


JAVA是强类型语言，需要定义类型，即数据可变，内存不变。
变量用于不断存放变化的常量，用于重复使用。

定义方法：
数据类型  变量名=初始化值；


数据类型包括两类：
    1. 基础数据类型：
                    a. 数值:
                            整数型：
                                    byte:8个bite
                                    short: 2个byte,即16个bite
                                    int: 4个byte，4个8位
                                    long: 8个byte，8个8位 (整数后面加l，表示long)
                            浮点：
                                    float:单精度,4个8位
                                    double:双精度， 8个8位

                    b.字符型（char）：2个byte, 2个8位，即‘你’ 一个中文字表示两个字节
                    c. 布尔（boolean）

    2. 引用数据类型：
                    class
                    interface
                    []
                    ....

tips:
    float f=2.3;   //会报错，类型不匹配，因为float是单精度，2.3是双精度
    float f=2.3f;  //标示放入float，正确，

    所以多用double

    long l=123；  //错误，123默认是整数类型，而不是长整数
    long l=123l;  //标示成长整数

    tips: 变量使用前，必须初始化值

基础类型提升&强制转换：

    int x=3;  //开辟一个内存名位x的内存，存入数据3，
    x=x+5;      //从x内存中取出数据3到运算区中，二进制运算3+5的结果，再存入X内存，原内存数据3被取代。

    运算两端必须同类型，不同类型不能运算。

    如果两端都是数值型，会有自动类型提升。
    即把不同数值类型转换成相同，以内存占有较大的位主。
    比如：
        int x=3;
        byte b=2;
        x=x+b;

        x是Int类型，有4个8位，
        b是byte类型，只有一个8位，
        当x+b相加时，结果会自动把byte类型提升为int类型，所以结果会是Int类型。

    但是：
        byte b=3;
        b=b+4; //错误，因为4默认为int类型，不能从int类型转换为byte类型，会丢失精度。

    面试基础题：
        byte b1=3, b2=4, b;
        b=b1+b2; //这里错误，因为b1 和 b2是变量，值不确定，检查不了，可能溢出，编译失败。损失精度
        b=3+4; //这里是对的，java看到整数默认为Int类型，在byte范围之内，java会自行检查，自动做一次强转。


    强制类型转换，如下：
        byte b=2;
        b=(byte)(b+2);  //因为b+2默认为Int类型，要放入byte类型，要用强制类型转换。
        b=byte(b+2)    //这里错误，因为这里byte是引用类型，不是基本数据类型，(byte)才是强转用的基本数据类型。

    Tips:强转慎用，因为有可能丢失精度。

    用字母加上数字会自动转换成数字：
    System.out.println('a'+1)  //结果是98.
    原因：
        根据ASCII表格，a在表中用97，代替，97+1=98，即是'b'的代表数字。
        ASCII是二进制与生活对应关系表，即编码表。
        ASCII----美国编码表；
        JB2312----中国编码表；
        JBK------国际扩展表
        Unicode ----国际标准码表（全世界码表）


算术运算符：

    JAVA是强类型语言。
    int/ int=int; //当Int类型与int类型做运算时，结果也是int类型。结果会舍弃小数位。
    比如：
        int x=6370;
        x=x/1000 * 1000; //结果是6000；
    %---->取余，模运算。
        5%-2 = 1；
        -5% 2=-1;  //负数只参考被模数。模数对被模数的正负没影响。

    '3'+'2'=32; 
    "a="+a+' '+"b="+b; //任何数据与字符串相加，都是连接。记住这里a和b的变量值会显示出来。

关于++(自增)和--(自减)。
     int a=3, b;
     b=++a; //a自增，再赋值给b。
     b=a++; //底层运算过程: 首先临时开辟一片区域预存，a的值，即是3，
              然后，a经过自增，值从3变成4.最后再从预存区域把值也给b，所以b是3.
    所以：
        int i=3;
        i=i++; //i的结果是3.
        过程：
            i内存中初始化是3；
            把3预存到临时区域，i进行自增运算，此时，i的值是3+1=4；
            再把临时区域中的值3，赋值给i，所以4被3取代。所以最后i内存中的值是3.
    总结，自增的运算顺序是：
        1. 先预存区记录变量的值；
        2. 变量实现自增。
        3. 再把预存区的值赋给要赋给相应的变量。

关于赋值： =、 += 、 -= 、 *= 、/= 、 %=
        short s=3; //short是两个字节；
        s+=4;  //正确，赋值，这是一次运算，java会检查数据大小，实现强制类型转换。
        s=s+4; //错误，因为s是个变量，值不能确定，结果不会检查，编译失败。


比较运算符：
    ==  //判断运算符
    =   //这是赋值
    instanceof  //比较运算符

逻辑运算符：
    用于连接两个boolean类型的表达式。
    &： 与-------> &&(短路)
    |: 或 -------> ||(短路)
    区别：左右的运算结果一样，但是过程有区别。
    & 和 | 一定会运算完，运算的右边一定会参与运算。同时还可以做位运算。
    && 和 || 的运算过程中，当运算过程中一旦发现结果就会停止运算。

    ^ : 异或运算符。
    规律：^符号两边结果相同时，结果是false；
         ^符号两边结果不同时，结果是true。
    ！：not.


位移运算：
    &： 与
    |： 或
    ^:  异或
    ~： 反码

    &位移运算：用0与1代表false与True.只有当两边都是1(true)时，结果才是1.

    6&3=2
    运算过程：
    110 ---->6
&   011 ---->3
----------------
    010 ---->2

    | 或运算： 只要有一边是1，即true，结果就是1.

    6|3=7
    运算过程：
    110 ---->6
|   011 ---->3
----------------
    111 ---->7

总结：
    &运算的特点：可以用1取最低位，即用1取某位数的后几位，几个1取几位。
    比如： 
        01001001000111
        00000000000111
        -------------------------
        取得就是最后三位数

    |运算的特点：保留有位数的有效位


^异或：两边相同为假，不同为真

    6^3=5
    5^3=6
    运算过程：
    110 ---->6
^   011 ---->3
----------------
    101 ---->5
^   011 ---->3
----------------
    110 ---->6

所以：6^3^3=6

总结：一个数异或同一个数两次，结果还是这个数。
    可以用于数据加密，一个文件异或一次--->数据改变（加密）---->再异或一次（解密）


~反码：用于取反动作。一个正数取反，一定会是一个负数。
~6 ----->-7

位移运算：
<< (左移)： 往左移就是高位丢失，低位用0补。
比如：
    3<<2 =12 =====> 3*2^2=12
    即3往左移两位，高位丢掉，低位用0补

    0000-0000 0000-0000 0000-0000 0000-0011 ---->3左移两位
    0000-0000 0000-0000 0000-0000 0000-1100 ---->结果是12.

    3<<3 = 24  3*2^3=24
所以，左移几位，其实就是用该数据乘以2的几次方。即可以完成2的次幂运算。

>> (右移)：往右移就是往右移时，高位补位时，以前是什么就用什么补。
比如：
    6>>1=3
    0000-0000 0000-0000 0000-0000 0000-0110 ---->6右移1位
    0000-0000 0000-0000 0000-0000 0000-0011 ---->结果是3.
    6>>2 =1
所以,右移几位，其实就是用该数据除以2的几次方。

>>>(无符号右移)：和右移基本一致，区别是：数据进行右移时，高位出现的空位，无论原高位是什么，空位都用0补。

位移符号的一些应用：
    1. 最有效率的算出2乘以8等于几，即算出任何数字乘以2的次幂的结果。
        2<<3;
        2*8；
    2. 对两个整数变量的值进行互换（不需要第三方变量）
        a=a^b;
        b=a^b;
        a=a^b;
    缺点：阅读性差

Java基础三元运算符：
    （条件表达式）？表达式1：表达式2；
    举例：
        int x=3,y=4,z;
        z=(x>y)?x:y;  //这是运算符，会有结果

Java基础句 if语句
    if(){....这里是if语句的控制范围}
    if(...)x=1; //当只有一句语句时，可不用大括号。
    第一种：
    int x=1;
    if(x>1)
        if(x<2){
            yes;
            over;
        }  
        //在这里，第二个if是被第一个if语句控制的，因为if会控制接下来的一句语句。
    
    第二种：
    int a=3, b;
    if(a>1)
        b=100;
    else                    <=======>  b=(a>1)?100:200;
        b=200;

        //三元运算符就是if else简写格式，与if else的区别是三元运算符一定会有结果，但是if else不一定。
            所以当if else 运算后，有一个具体结果时，用简化
        
    第三种：
    if(...){

    }
    else if(...){

    }else{

    }  //这里只有一个代码块会执行

    if(...); //这里的if不控制任何语句

    tips: 语句的结束方式两种：
        1. ；
        2. }

基础局部代码块：
    可以定义局部变量的生命周期
    {...} //局部代码块，用于封装、节省空间

    比如：
    {
        int m=89;
        System.out.println(m); 
    } //当局部代码块结束，m的内存空间释放。
    System.out.println(m); //这里错误，因为变量有作用域，作用范围在{}内

tips:凡是主函数变量，都是局部变量。

    








    




        

        




    
    
