    继承 概述
        class Person{}
        class Students extends Person{}
        class worker extends Person{}
        //产生继承关系，相当于子类中有父类的过程

    继承的好处：
        1. 提高代码的复用性
        2. 让类与类之间产生关系，给第三个特征多态提供了前提。

    继承就是一个不断向上抽取的过程。
    先分析这个过程，分析完以后写代码先写父类。

    Java中的单继承和多继承：
        Java中支持单继承，不直接支持多继承，但对C++中的多继承进行了改进。
    
        单继承：一个子类只能有一个直接父类
        多继承：一个子类可以有多个直接父类（Java中不允许，进行了改良，通过多实现的方式体现）
        原因：当两个父类有相同的方法或成员变量时，会产生调用的不确定性。

        Java支持多层（多重）继承：
            即C继承B，B继承A。
        这样会形成继承体系。
        当使用一个继承体系时，
            1.查看体系中的顶层类，了解该体系的基本功能
            2.创建体系中的最子类对象，完成功能的使用。

    定义继承：
        什么时候继承？
            当类与类之间存在所属关系的时候，定义继承。
            xxx是 yyy的一种，即可 xxx extends yyy
        所属关系：
            is a 的关系。 cat is an animal.

    子父类中成员变量的特点：
        成员变量：
            当本类的成员与局部变量重名时，用this区分。
            当子父类中的成员变量重名时，用super区分父类。
        
        this和super的用法很相似：
            this:代表一个本类对象的引用
            super:代表一个父类的空间，在子类中没有对象，只是一个空间。

    子父类成员变量的内存图解
        class Fu{
            int num=4;
        }

        class Zi extends Fu{
            int num=5;
            void show(){
                sop(this.num+'..'+super.num);
            }
        }
     
        加载子类进入方法区时，父类先加载，因为子类与父的东西。

        在创建子类对象时，父类不会创建对象，但是子类继承父类，在子类对象中会有父类的内容。
        子父类会分空间存储，在子类对象中，会开辟一个父类空间，super代表了这个父类空间。

        父与子有相同成员变量的情况几乎没有
        成员变量一般私有
        父类中的私有内容子类持有
        但是子类不能直接访问父类中的私有内容，需要用get()等方法获取。
        当调用方法时，子类会先在自己的方法中寻找，如果没有，再会拿super到父类中寻找。


        子父类中成员函数的特点：
            class Fu{
                void show1(){}
            }
            class Zi extends Fu{
                void show2(){}
            }
            class ExtendsDemo{
                mian(){
                    Zi z=new zi();
                    z.show1();
                    z.show2(); 
                }
            }
            
        当子父类中，出现成员函数一模一样的情况，会运行子类的函数，这种现象叫做覆盖（override）

        tips:函数的两个特性：
            1.重载，同一个类中(overload)
            2.覆盖，子父类中，子类同名函数覆盖父类的函数，覆盖称为重写、覆写（override）

        覆盖注意事项：
            1.子类方法覆盖父类方法时，子类权限必须要大于等于父类权限
            2.静态只能覆盖静态，或被静态覆盖。

    覆盖的应用：
        什么时候使用覆盖？
            升级不要修改源代码，一般不对源代码进行修改，用继承进行升级。
            保留父类原有功能，修改功能的具体内容。
            当对一个类进行子类拓展时，子类需要保留父类的功能声明，但要定义子类中该功能的特有内容时，就使用覆盖操作完成。
            在子类的函数中用super调用原有函数，再加上自己的特有内容。

    子父类中的构造函数 子类的实例化过程
        在子类构造对象时，发现、访问子类构造函数时，父类也运行了，为什么？
            原因是，在子类的构造函数中，第一行有一个默认的隐式语句，super()调用的就是父类中的空参数的构造函数。

            默认会有super(),即父类中空参数构造函数，当父类没有空参数构造函数时，在子类中需要自己用super定义一下。

        tips:构造函数不能覆盖和继承

        子类的实例化过程：
            子类中所有的构造函数，默认都会访问父类中的空参数的构造函数。

    子父类的构造函数 子类的实例化过程 细节：
        为什么子类实例化时要访问父类的构造函数？
            因为子类继承父类，获取到了父类的内容（属性），所以在使用父类内容前，要先看父类如果对自己的内容进行初始化的。
            所以子类在构造对象时，必须访问子类中的构造函数，为了完成这个必须的动作，就在子类的构造函数中加入super()语句。

        如果父类中没有定义空参数构造函数，那么子类构造函数必须用super明确要调用父类中哪个构造函数
        
        tips:super语句必须定义在子类构造函数第一行，因为父类的初始化动作要先完成。
             子类的构造函数如果使用this调用本类的构造函数时，super就没有了，因为super和this都只能定义在第一行，所以只能有一个，
             但可以保证的是，子类中肯定有其他的构造函数访问父类的构造函数。

             创建的任何类都是Object中的子类。

        class Fu{
            fu(){
                show();
            }
            void show(){
                sop("Fu show");
            }
        }

        class Zi extends Fu{
            int num=8;
            zi(){

            }

            void show(){
                sop("zi show..."+num);
            }
        }

        main(){
            Zi z=new Zi();
            z.show();
        }   //这里的output是： zi show...0      zi show...8

        这里当创建子类对象时，在运行子类构造函数前，子类对象会有默认初始化 num=0，然后会运行父类的构造函数super()，此时super调用show()函数，因为这个父类在子类对象中，
        先在子类中寻找show（）方法，所以输出 zi show...0；
        然后父类构造函数弹栈，子类构造函数进栈，进行显示初始化，num=8.
        最后调用子类中的成员函数show() 输出 zi show...8

        构造器分水岭：
            先执行完父类的初始化，再是子类的显示初始化。
            通过super（）的初始化父类内容时，子类的成员变量并未显示初始化。
            等super()父类初始化完毕后，才进行子类的成员变量显示初始化。

        一个对象实例化过程：
            1.JVM会读取指定路径下的Person.class文件，并加载进内存，并会先加载Person的父类（如果有直接父类的情况下）
            2.在堆内存中开辟空间，分配地址
            3.并在对象空间中，对对象中的属性进行默认初始化。
            4.调用对应的构造函数进行初始化
            5.在构造函数中，第一行会先调用到父类中的构造函数进行初始化。
            6.父类初始化完毕后，才进行子类的成员变量显示初始化。
            7.再进行子类构造函数的特定初始化
            8.初始化完毕后，将地址值赋值给引用变量。

        

    Final 关键字
        可修饰类、方法、变量。

        tips:继承的弊端：打破封装性。

        Final 关键字
        1.是一个修饰符，可修饰类、方法、变量
        2.Final修饰的类不可以被继承
        3.Final修饰的方法不可以被覆盖
        4.Final修饰的变量是一个常量，只能赋值一次（常量都用大写，单词与单词之间用下划线连接）

        Final固定的是显示初始化值，所以被Final修饰的都需要初始化。
        成员被final修饰，一般会加static.

    
