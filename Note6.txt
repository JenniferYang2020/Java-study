Abstract Interface and polymorphism
    抽象类：笼统 模糊 不具体
        当两个类有相同的功能（函数声明），但具体内容不同，所以向上抽取时，只抽取函数声明，用abstract 修饰，称为抽象函数。
        抽象函数所在的类也要被abstract修饰，称为抽象类。
        abstract class demo{
            abstract void show();
        }

    抽象类的特点：
        1.方法只有声明没有实现时，该方法就是抽象方法，需要被abstract修饰。
          抽象方法必须定义在抽象类中，该类必须被abstract修饰。
        2.抽象类不可以被实例化。因为调用抽象方法没有意义。
        3.抽象类必须有其子类覆盖了所有的抽象方法后，该类才可以实例化，否则这个子类就是抽象类。
            （即如果抽象类被继承，其子类要覆盖抽象类中的所有抽象方法，不然这个子类还是个抽象类，不能被实例化）。

    抽象类的细节：
        1.抽象类有构造函数吗？
            有，用于给子类对象进行初始化
        
        2.抽象类可以不定义抽象方法吗？
            可以的，但是很少见，目的就是不让该类创建对象。
            AWT的适配器对象就是这样，通常这种类中的方法有方法体，但是没有内容。

        3.抽象关键字不可以和哪些关键字共存？
            private 不行，因为抽象需要被覆盖，Private之后不能被覆盖
            static 不行，因为用static就不需要对象
            final 不行，因为抽象需要被覆盖，final之后不能被覆盖

        4.抽象类和一般类的异同点：
            相同点:都是用来描述事物的，都定义了成员。

            不同点：
                1.一般类有足够的信息描述事物
                  抽象类描述事物的信息有可能不足。
                2.一般类中不能定义抽象方法，只能定义非抽象方法；
                  抽象类中可以定义抽象方法，也能定义非抽象方法。
                3.一般类可以被实例化；
                  抽象类不可以被实例化。

        5. 抽象类一定是父类吗？
            是的，因为需要子类覆盖其方法后才可以对自理实例化。

    定义interfacce
        interface()
            当一个抽象类中的方法都是抽象时，这时可以将该抽象类用另一种形式定义和表示，就是接口 interface.

        定义接口使用的关键字不是class，是interface.

        interface Demo{
            abstract void show();
            abstract void show2();
        }
        //编译完成以后仍然是class文件

        对接口当中常见的成员：
        1.全局常量，而且这些成员都有固定的修饰符（public static final）
            
        2.抽象方法： public abstract.
            tips:不写系统会自动加，最好写，阅读性和操作性强，由此得出结论，接口中的成员都是公共权限。


    实现 implements
        类与类之间继承关系
        类与接口之间实现关系

        接口不可以实例化
        只能由实现了接口的子类并覆盖了接口中所有的抽象方法后，该子类才能实例化，否则该子类是抽象类
    
    interface Demo{
        public static final int NUM=4;
        public abstract void show();
        public abstract void show2();
    }

    class DemoImp implements Demo{
        public void show(){}
        public void show2(){}
    }

    DemoImp d=new DemoImp();
    d.NUM;
    DemoImp.NUM;
    Demo.NUM;   //这三种方法都正确


    接口 多实现
        在java中不直接支持多继承，因为会出现调用的不确定性。
        所以java将多继承机制进行改良，在java中变成了多实现。
        一个类可以实现多个接口

        interface A{
            public void showA();
        }
        interface B{
            public void showB（）；
        }
        class Test implements A,B{
            ...
        }

    接口 细节：
        一个类在继承另一个类的同事，还可以实现多接口
        class Test extends Q implements A,B{
            ...
        }

        接口的出现避免了单继承的局限性。
        接口与接口之间是继承关系，而且可以多继承。
        interface QQ extends ZZ,MM{

        } //这里QQ , ZZ和MM都是接口

        class WW implements QQ{
            ...
        }//WW需要覆盖QQ,ZZ,MM中的所有方法。

    
    接口的特点
        接口是对外暴露的规则，即程序的功能拓展。
        接口的出现降低了耦合性
        接口可以用来多实现
    
    接口和抽象类的区别：
        相同点：都是不断向上抽取而来的。
        不同点：
            1.抽象类需要被继承，而且只能单继承
              接口需要被实现，而且可以多实现
            2.抽象类中可以定义抽象方法和非抽象方法，子类继承后，可以直接使用非抽象方法。
              接口中只能定义抽象方法，必须有子类实现。
            3.抽象类的继承，是is a关系，在定义该体系的基本共性内容。
              接口的实现是like a关系，在定义体系的额外功能。

    接口的应用：
        先定义规则，即接口。接口定义规则，子类实现规则。

        笔记本电脑的使用：
            为了拓展笔记本的功能，但日后出现什么功能还不知道，定义一个规则，只要日后出现的设备都符合这个规则就可以了，规则在Java中就是接口。

            interface USB{
                public void open();
                public void close();
            }

            class Bookpc{
                public static void main(String[] args){
                    useUSB(null);
                }
                public static void useUSB(USB u){
                    u.open();
                    u.close();
                }
            }
            //接口类型引用类类型变量。
            接口性引用指向的都是接口的子类对象。所以这里的USB u引用指向的应该是实现了接口USB的子类对象。
            接口类型的引用，用于接收（指向）接口的子类对象。

        接口的应用：
            暴露规则
            使用规则
            实现规则
            耦合性降低

    多态 概述
        多种形态--->对象的多态性
        猫 X=new 猫（）；
        动物 X=new 猫(); //动物类型指向猫对象，父类引用指向子类对象 --->多态

        一个对象具备多种形态
        即猫即具备猫的形态，有具备这动物的形态
        一个对象对应着不同类型

        多态在代码中的体现：
            父类或接口的引用指向其子类对象。一个对象两种形态。

    多态 好处
        提高了代码的拓展性，前期定义的代码，可以使用后期的内容

    多态 弊端和前提
        前期定义的内容不能使用(调用)后期子类的*特有*内容

        多态的前提：
            1.必须有关系--->继承或者实现
            2.要有覆盖
        
    多态 转型
        Animal a=new Cat(); //自动类型提升，猫对象提升成了动物对象，能访问猫和动物的共性内容，但是猫的特有功能无法访问，作用是限制特有功能访问。
        a.eat(); //调用共性内容
        a.catchMouse(); //这里ERROR，不能调用特有内容
        这里猫提升为动物对象，叫向上转型。

        如果还想用具体动物猫的特有功能，可以实现向下转型。
        Cat c=(Cat)a; //向下转型的目的是为了使用子类中的特有方法。
        tips：对于转型，自始至终都是子类对象在做类型变化。

    多态 转型2
        儿子 x=new 儿子();
        x.讲课（）; //这是儿子本身就有的功能
        x.钓鱼（）;//可以，因为调用的是父类方法，子继承父，不是子类特有的方法。

    多态 类型判断 instanceof
        if(a instanceof Cat){ //a是动物，但具体类型是cat 所以是true。
            cat c=(cat)a;
            c.catchMouse();
        }
        instanceof 用于判断对象的具体类型，只能用于引用数据类型的判断。
        一般用于用下转型之前，用于健壮性判断。

    多态 成员变量
        多态时，成员的特点
        成员变量： 
            编译时，参考引用变量所属的类中是否有需要调用(使用)的成员变量，有，编译通过，没有编译失败。
            运行时，参考引用变量所属的类中是否有需要调用(使用)的成员变量，并运行该所属类中的成员变量。

            class Fu{
                int num=3;
            }
            class Zi extends Fu{
                int num=4;
            }

            Fu f=new Zi();
            SOP(f.num);   //这里输出的是3.如果父类中没有num，会报错。

        总结，成员变量都看左边，即看引用型变量所属的类的具体内容。

    多态 成员函数  //有覆盖，运行子类
        函数不是非静态，依赖于对象运行，所以哪个对象运行，调用哪个方法。
        编译时，参考引用型变量所属的类中是否有调用的函数，有，编译成功，没有，编译失败。
        运行时，参考对象所属的类中是否有调用的函数
        
        class Fu{
            void show(){
                SOP("Fu show");
            }
        }

        class Zi extends Fu{
            SOP("Zi show");
        }

        Fu f=new Zi();
        f.show(); //输出 Zi show.

        总结：成员函数编译看左边，运行看右边。

    多态 静态函数
        调用时不依赖对象，依赖于引用类。
        编译和运行：参考引用型变量所属类中是否有调用的静态方法。
        其实对于静态方法，是不需要对象的，直接用类名调用即可。

    



