JAVA基础数组：
    格式1：
        元素类型[] 数组名=new 元素类型[元素个数或数组长度]；
        int[] arr=new int[5];

    格式2：
        元素类型[] 数组名= new 元素类型[]{元素，元素，元素，....};
        int[] arr=new int[]{3,4,5};
    
    Tips:
        1. 创建一个数组，必须确立长度；
        2. 数组中的值没有确定会有默认值；
            int----0
            object----null
        [] ---->意味着数组

数组 内存空间划分：
    JVM会对Java进行内存划分，
    JVM内存划分有5片：
        1. 寄存器 --->给CPU用
        2. 本地方法区 ---->本地系统平台中的内容，和所在系统有关，版本不同
        3. 方法区 ----->暂时讲不到
        4. 栈内存
        5. 堆内存

        tips：{
            age=3;
        }   //这是局部代码块，限定局部变量的生命周期。

        栈内存：
            存储的都是局部变量，即凡是定义在方法中的变量，而且变量所属作用域一旦结束，该变量自动释放。
            特点：更新快，生命周期短。
        
        堆内存：
            存储的是数组和对象（其实数组就是对象的一种） 
            也可以理解为，凡是new的都建立在堆中。
            特点：
                1. 每个实体都有首地址值
                2. 堆内存中的每个变量都有默认初始化值： 整数--0， 小数--0.0 或者 0.0f, boolean--false, char-- '\u0000'
                3. 堆内存中有垃圾回收机制对其内存进行回收再利用。
                    int [] arr=new int[3];  //new时会在堆内存开辟空间，封装数据实体
                    /*
                        第一步，主函数进栈，开辟空间；
                        第二步，主函数中创建变量arr;
                        第三步：在堆内存中开辟空间创建一个长度为3的数组，并且声称地址值（0X0045）地址是连续的二进制，十六进制
                        第四步，把堆内存中的空间地址值赋给变量arr。
                    */
                
                                            //此时，堆内存中的变量都有初始化值
                    arr[0]=89;
                    arr=null; //取消引用变量的指向。arr不再指向堆内存中的某个地址。
                    tips:当堆中的对象没有引用后，变为垃圾，垃圾回收机制不定时检测，自动回收。

                int[] x=new int[3];
                int[] y=new int[3];

                x=y;//两个变量指向同一实体
                即：多个引用变量可指向同一实体。

    76 常见问题：
        int[] arr=new int[3];
        sop(arr[3]);  //ArrayIndexoutofBoundsException
        //这里编译可以通过，因为编译只检查语法，不开辟空间运行，
        //但是运行不可以，JVM创建空间时会有问题。
        
        arr=null;
        sop[(arr[0]) //NullPointerExecption,即当引用型变量没有实体指向还在操作实体。
        //编译可以，运行不行

        sop(arr) //此时打印的是数组地址的哈希值。 [I@c17164---->[ 意味着数组， I意味着整数， @c17164是数组的实体地址

    77 JAVA数组的第二种定义
        2. int[] arr=new int[]{1,2,3,...}; //
        3.int[] arr={1,2,3...} //静态初始化，不用new 运算。
        核心思想对角标操作

    78 数组的遍历
        length of Array:arr.length;
    
    79 最值
        
    80 基础数组  选择排序
        数组给一个function,是把内存给function，在内存中操作，操作完以后，内容改变。
    
    81冒泡排序：相邻相比，最大的会自动到最后。

        public static void bubbleSort(int[] arr){
        for(int i=0;i<arr.length-1;i++){  //第一个外循环控制排序躺数
            for(int y=0;y<arr.length-1-i;y++){ //内循环控制每一次排序多少次
                if(arr[y]>arr[y+1]){
                    int temp=arr[y];
                    arr[y]=arr[y+1];
                    arr[y+1]=temp;
                }

            }
        }
    }

    Java内置排序：
        Array.sort(arr); //java用的最快排序，希尔排序，用的是位运算
    
    排序性能问题

    查找：
        没有查到return -1, 返回数 -1 最合适，返回负数知道角标不存在

    折半查找：前提，被查数组必须有序
        （endIndex+startIndex）/2  //找中间位置

        Array.binary.Search  //java api 自动二分查找
            比如：binary(arr,50); //不存在，返回插入点的负数。负数是位了告诉你找不到，插入点告诉你可以在哪里插入。


    Java基础进制转换：
        获取一个16进制的表现形式。
        0000-0000 0000-0000 0000-0000 0011-1100   //这是60
        //每三位二进制是八进制，四位代表一位更短，16进制。
        要想把上面的数字换成16进制，就是4位代表一位。

        0011-1100
        3----C   //3C

        用计算机算，把一个数换算成16进制：
        第一步：&15，取最低四位的有效位数。
        第二步：去完以后，转成一个整数。
        第三步，不断向右移4位，继续取下四位， num>>>4
        第四步，再取后四位做换算，直到剩下的数字为0.
        总结：一个数组换算成16进制就是不断&15，然后右移。


            public static void toHex(int num){
        char[] arr={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
        char[] res=new char[8];
        int index=0;
        while(num!=0){
            int temp=num&15;

            //定义一个对应关系表
            
            
            res[index++]=arr[temp];
            
            num=num>>>4;
        }
        for(int i=res.length-1;i>=0;i--){
            System.out.print(res[i]);
        }
        // int n1=num&15;
        // System.out.println(n1);

        // num=num>>>4;
        // int n2=num&15;
        // System.out.println(n2);
    }
        
        如果数据出现对应关系，而且对应关系一方是有序的数字编号，可以作为角标使用。就可以将这些数据存储到数组中--->查表法。

        操作数组一定要角标，所以数组加元素时，用角标。

        Tips:void方程可以用 return 结束

        十六进制，
        八进制，
        二进制。
        Integer.toBinaryString(6);
        Integer.toHexString();

    二维数组：即数组内存数组
        int [][] arr=new int[3][2]; //定义了一个二维数组，这个数组是3个长度均为2的数组
        int[][ ] arr=new int[3][];
        arr[0]=new int[3];
        arr[1]=new int[4];
        arr[2]=new int[1]; //分别对二维数组中的每个小数组进行初始化。

        tips：在二维数组中，大数组中存储的是小数组的地址值，是实体，所以初始化值为Null
        
        1.创建数组时，大数组默认为Null，
        2.开辟二维数组得到地址，
        3.地址赋给第一维。

        int [][] arr=new int[3][];
        System.out.println(arr); //输出地址值，
        System.out.println(arr[0]); //null，因为此时还没有具体的指向空间
        System.out.println(arr[0][0]); //可编译,runtime error.

    面向对象：对应的是面向过程

    面向过程：                      面向对象：
    强调的是动作                    强调的是对象（实体）
    打开冰箱                        冰 箱：打开冰箱，存储，关上的功能。 
    存储冰箱                                即冰箱将所有动作进行封装。
    关上冰箱        

    面向对象的特点：
        1.面向对象是一种思考习惯
        2.面向对象将复杂问题简单化
        3.让曾经在过程中的执行者，变成对象中的指挥者。

    对象类和对象之间的关系：
        蓝图（blueprint） --->描述事物

        对象是事物的具体体现

        类：对现实生活中的事物进行描述
        怎么描述：
            1. 属性（Attribute） 即Data
            2. 行为（behavior） 即function

        对象：用new产生该类的对象。
             是该类事物实实在在存在的个体，即实例。

        类与对象的关系：
            类：事物的描述
            对象：该类事物的实例

        面向对象类和对象的体现：类类型变量
        class Car{
            int num;
            String color;
            void run(){
                System.out.println(num+".."+color);
            }
        }

        class CarDemo{
            public static void mian(String[] args){
                Car c=new Car(); //类类型的引用变量指向该类的对象


            }
        }   //这两个class可以在同一文件中，也可以在不同文件中，但要在同一路径下。


    类的成员：
        只要是类（事物）中的组成部分，都是成员。
        成员分为:成员函数
                成员变量。

        定义类就是定义类中的成员。
        成员变量： 即属性           局部变量：定义在方法或语句中的变量。
        成员函数： 即行为                   

    面向对象的对象内存：
            Car c=new Car();
            c.num=4;
            c.color="red";
            c.run();

            首先在栈中加载主函数，创建引用变量c;
            然后在堆内存中开辟空间，创建对象new Car();
            在对象中存在成员变量num和color,num的默认初始化值是0，color是Null.
            然后把堆内存中对象的地址赋值给引用变量c。

    面向对象成员变量和局部变量的区别：
            1. 成员变量定义在类中，整个类都可以访问；
               局部变量定义在函数、语句和局部代码块中，只有所属区域有效
            2. 成员变量存在于堆内存的对象中；
               局部变量存在于栈内存的方法中   
                tips： 对象中的function在哪个内存运行？---->调用方法都会进栈！！
            3.生命周期不同；
              成员变量随着对象的创建而存在，随着对象的消失而消失
              局部变量随着所属区域的执行而存在，随着所属区域的结束而释放。
            4. 成员变量有默认初始化值
               局部变量没有默认初始化值。
                    
            tips:当调用对象的方法时，方法进栈，在栈内存中运行。所有方法都在栈内存中运行。

    面向对象类型参数：
        public staic void show(Car c){ //类类型变量一定指向对象，不然就是空。
            c.num=3;
            c.color="black";
        }
    
    面向对象匿名对象： 即没有名字的对象
        new Car(); //定义对象的简写格式
        new Car().run();
        new Car().run(); //这里是分别创建了两个对象，分别调用其成员函数。

        所以当对象对方法仅进行一次调用的时候，就可以简化成匿名对象。这里调用变量没有意义，因为用不到。即：

        new Car().num=5;  
        new Car().color="Green"   //这些语句运行完就结束，所以调用变量没意义。

    面向对象： 基本数据类型参数传递图解：
        public static void main(String[] args){
            int x=3;
            show(x);
            sop(x);//这里输出3，因为show中的x=4，随着function show（）的结束而释放了。
        }

        public staic void show(int x){
            x=4;
            return;
        }

    面向对象：引用数据类型参数传递图解：

    public class Demo {
    int x=3;
    public static void main(String[] args){
        Demo d=new Demo();
        d.x=9;
        show(d);
        System.out.print(d.x);  //这里输出的是4，因为在引用数据类型作为参数时，传递的是堆内存空间，在队堆内存中的成员变量进行改变以后，对象中的数据随之改变。

    }

    public static void show(Demo d){
        d.x=4;
    }
    
}

    面向对象：封装（Encaplsulation）
        隐藏对象的属性和实现细节。
        创建对象后，直接访问对象的数据，会存在安全隐患。
        使用 private： 限制访问权限，只在本类中有效。

        成员属性可以私有，对外开放一些方法。
        成员变量一般私有，用get , set对属性进行操作。
        设置属性后，高级编辑器可以用快捷键创建get, set function.

    封装思想：
        隐藏对象的属性和实现细节，仅对外提供访问方法。
        优点：
            1. 安全
            2. 方法对属性进行控制
            3.提高复用性
            4.隔离变化

        原则：
            将不需要对外提供的内容隐藏起来，
            属性隐藏，提供公共方法对其访问。
            不需要对外的funtion都可以隐藏（private）

        private：是权限修饰符，用于修饰成员，表示私有内容只在本类中有效。

        private：私有，仅仅是封装的一种表现形式。
        私有是封装，封装不是私有。其实只要是隐藏都是封装
        Java中最小的封装体：function.

    构造函数：constructor
        特点：
            1. 函数名和类型相同
            2.不用定义返回值类型
            3.没有具体的返回值。
            tips:构造函数对对象进行初始化，即当创建对象时进行自行的调用

            class Person{
                Person(){
                    sop('Person run');
                }
            
            }
            Person P=new Person(); //构造函数是创建对象时调用的函数。

    默认构造函数：
        创建对象都需要通过构造函数初始化。
        一个类中如果没有定义过构造函数，那么该类中有一个默认的空参数构造函数。
        如果在类中定义了指定的构造函数，那么类中的指定构造函数就会没有。

    构造函数和一般函数的区别：
        构造函数： 对象创建时，就会调用与之对应的构造函数，可以对对象进行初始化。
        一般函数： 对象创建后，需要函数功能才调用

        构造函数： 对象创建时，只调用一次。
        一般函数： 对象创建后，可以调用无限次。


    构造函数重载：（overloading） 对应的是重写（overriding） 重写是父类与子类之间，子类继承了父类的方法，重写具体实现过程。
        什么时候定义构造函数：
            在描述事物时，该事物已存在就具备的一些内容，这些内容都定义在构造函数中。
            一个类可以有多个构造函数，叫重载。
            方法名一样，参数不同。
            Person(int a , String n)；
            Person(String n, int a); //这是重载，顺序不一样，参数不同。

    构造函数的内存图解。
        Person p2=new Person('小强'，10)；
        p2.speak();

        1. 主函数进栈，创建引用变量P2;
        2.在堆中创建对象，并默认初始化值；
        3.构造函数进栈，初始化对象的值，在构造函数中有一个引用变量this指向调用这个方法的对象，即指向在堆中调用这个构造函数的地址值。
        4.通过this,把构造函数中的内容赋给调用它的对象。
        5. 把对象的地址赋给在主函数中指向他的引用变量P2。
    
    构造函数细节：
        Person(String n){
            name=n;
        }
        public static void setName(String n){
            name=n;
        }
            //这两个方法功能一样，但两个都要写。因为构造函数是初始化，而setName可以对数据进行多次改变。他们的功能目的是不一样的。
        tips：构造函数可以调用一般函数，一般函数不能直接调用构造函数。
        void Person(){

        } //这个函数加了返回类型，变成了一般函数，所以：构造函数首字母大写，一般函数首字母小写。
        构造函数有return语句，但是很少见。

        Person(String name){
            name=name;  //局部变量与成员变量重名，这里是局部变量，把自己赋给自己，对象中的变量没有被赋值
        }
        Person p=new Person("旺财")； //此时，对象中的name 是null.

        可以改成： this.name=name; //this表示这个对象的变量name.

        *当成员变量和局部变量重名，可以用关键字this区分。
        
        this:代表对象
                当前对象 <====>哪个对象调用了this所在的函数，this就代表哪个对象。

            this 就是所在函数所属对象的引用。
            当函数被调用时，this代表调用这个函数的对象。
        tips:this 一定在函数中。
        凡是被对象调用的方法，都持有this引用。
        this指向哪个对象，哪个对象就在调用this所在的函数。
        










    







                